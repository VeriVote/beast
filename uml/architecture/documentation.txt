This document describes the architecture for beast,
with most attention to the logical throughline and suggestions
on where to start if a dev wants to implement new features

In general, the project has two halves: 
- The functionality of beast, such as 
	code generation, 
	calling cbmc, 
	and giving the results back, 
	
which is in the packages edu.pse.beast.api.*

And the GUI, which uses this api 

which is in the packages edu.pse.beast.gui.*

The gui is implemented in javafx, which uses fxml files created
with GLUON scenebuilder to describe the gui.

The fxml files can be found in src/main/resources/edu/pse/beast/*.fxml

although for example, the beastworkspace is part of the gui, and the 
saving and loading functionality is part of the api. However,
the saving loading functionality knows about beastworkspace so it
can persist it. In general, there are a few cases where the separation
probably isn't 100% accurate.

The GUI:

If the user wants to start the tool through the gui,
the programm starts execution in the class
edu.pse.beast.gui.BeastWithGuiApplicationClass

which build the main gui controller 

edu.pse.beast.gui.BeastGUIController

which contains all the gui startup logic, builds the other gui elements,
and links them up to the edu.pse.beast.gui.workspace.beastworkspace.

The most important class for understanding the gui is

edu.pse.beast.gui.workspace.BeastWorkspace

which is called into by all other gui elements. The workspace
embodies a kind of "session" element, storing opened election descriptions,
property descriptions, run, run results, etc. 

If any of the gui elements want to effect some change such as load another 
election description or update the code of a property or launch a 
cbmc test run, they call into beastworkspace. Beastworkspace manages
the state and then notices the gui elements which can register as 
WorkspaceUpdateListener.

This seperation isn't 100% clean, and sometimes the gui controller will do some
work before calling into the beastworkspace. This could be cleaned up.

Another discrepancy in the gui architecture is the following:
The main gui controller, BeastGUIController, loads one big fxml
(BeastGUI.fxml), which contains all the gui controlls for the sub
controllers such as edu.pse.beast.gui.ceditor.CElectionEditor.

This means, the controlls get injected into  BeastGUIController, which passes
them onto the other controllers through their constructors.

This can be made more elegant by moving the control panes for the seperate controls
into different fxml files, and using FXMLLoader to load these fxml files.

I started doing this later with the edu.pse.beast.gui.testconfigeditor.TestConfigTopLevelGUIHandler.

This code

private TestConfigGuiController testConfigGuiController;
	private FXMLLoader testConfigFXMLLoader = new FXMLLoader(
			getClass().getResource(testConfigDetailFXML));
			
loads the file testConfigDetailFXML, and the javafx subsystem injects the correct
controlls directly into TestConfigGuiController (for example).

OPTIONS

Options are local configurations such as font size or, in the case of windows,
where the VsDevCmd is stored. The implementation can be found under

edu.pse.beast.gui.options.*

BEAST Api

The part of beast which implements all the functionality such as generating the
code and communicating with beast could also be used without the gui.

CODE GENERATION

the cbmc code generation functions as such:

edu.pse.beast.api.codegen.cbmc.CBMCCodeGenerator gets passed
the CElectionDescription, PreAndPostPropertyDescriptions, and
CodeGenOptions. Then, it generates the voting function which
takes a struct as input and returns a struct.

The property description is turned into an AST by first using antlr
to parse it and walk through the tree generated by antlr with 
edu.pse.beast.api.codegen.booleanExpAst.BooleanCodeToAST.

BooleanCodeToAST generates a special AST which is then used to
generate the cbmc code using 

CBMCMainGenerator which in turn uses CodeGenASTVisitor
to visit each node in the generated ast and generate the code.

All AST nodes are defined in edu.pse.beast.api.codegen.booleanExpAst.nodes.*

most code is generated by using a template in 

edu.pse.beast.api.codegen.code_template.templates

and corresponding helper function in edu.pse.beast.api.codegen.helperfunctions

each node either produces a piece of code which will create a boolean
or another type. The names of those generated types are pushed and
popped from a stack. For example, the expression

(a > b) || (VOTES1 == VOTES2)

first gets translated to the AST

OR

- LESS-THAN (LHS: a, RHS: b)

- VOTE-EQUALS (LHS: 1, RHS: 2)

which the gets visited as such:

or gets visited and first visits its lhs child node.

This node generates a boolean, lets call it alessb,
and pushes it onto the stack.

the call returns, and or now visits the rhs child node.

The code to compare two vote arrays gets generated,
depending on which format the input type has. The generated boolean is called
votesequal and gets pushed onto the stack.

Or pops both boolean names off the stack, and adds the code

assert(alessb || votesequal).

How to change BEAST:

ADDING TO THE GRAMMAR
first, add the grammar rules to the antlr file in 
/Beast/src/main/antlr4/edu/pse/beast/toolbox/antlr/booleanexp/FormalPropertyDescription.g4

then, add the necessary nodes to the AST, 
in edu.pse.beast.api.codegen.booleanExpAst.nodes.*

and add the functions to generate those nodes to BooleanCodeToAST

Then, add add the code templates to edu.pse.beast.api.codegen.code_template.templates

helperfunction to create code out of those templates to edu.pse.beast.api.codegen.helperfunctions

and finally, call the helperfunction from CodeGenASTVisitor

which implements BooleanAstVisitor, so first add the function definitions there.

ADDING SAVING OR LOADING FUNCTIONALITY

Beast stores data using json. All saving and loading happens in the 

edu.pse.beast.api.savingloading.* packages. 
Have a look at the code there and add a new class where needed.

ADDING TO THE GUI
First, define the gui in scenebuilder and store the fxml where the others
are stored.

Then, depending on where the gui element lives, create it e.g. using BeatGUIController.

ADDING OPTIONS TO THE MENU

The menu gets created in BeatGUIController. 

ADDING NEW OPTIONS

Add a new sub package under edu.pse.beast.gui.options.*
derive the class OptionsCategoryGUI




